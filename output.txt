ðŸ“„ lib/api.ts:
    // lib/api.ts
    export const runTool = async (toolName: string, params: Record<string, string>) => {
        try {
          let endpoint = '';
          let payload = {};
      
          switch (toolName) {
            case 'Subdomain Finder':
              endpoint = '/api/subdomain';
              payload = { domain: params.domain };
              break;
            case 'WAF Detector':
              endpoint = '/api/waf';
              payload = { domain: params.domain };
              break;
            default:
              throw new Error('Tool not supported');
          }
      
          const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(payload),
          });
      
          if (!response.ok) {
            throw new Error(await response.text());
          }
      
          return await response.json();
        } catch (error) {
          console.error('Error running tool:', error);
          throw error;
        }
      };ðŸ“„ lib/prism.ts:
    // lib/prism.ts
    import Prism from 'prismjs';
    import 'prismjs/themes/prism-tomorrow.css';
    
    // Import bahasa yang diperlukan
    import 'prismjs/components/prism-javascript';
    import 'prismjs/components/prism-typescript';
    import 'prismjs/components/prism-jsx';
    import 'prismjs/components/prism-tsx';
    import 'prismjs/components/prism-python';
    import 'prismjs/components/prism-bash';
    import 'prismjs/components/prism-markup';
    import 'prismjs/components/prism-css';
    import 'prismjs/components/prism-json';
    
    // Inisialisasi Prism
    if (typeof window !== 'undefined') {
      Prism.highlightAll();
    }
    
    export default Prism;ðŸ“„ lib/tools.ts:
    export interface Tool {
      id: string
      name: string
      description: string
      category: string
      status: string
    }
    
    export const tools: Tool[] = [
      {
        id: "1",
        name: "Subdomain Finder",
        description: "Find subdomains of a target domain.",
        category: "recon",
        status: "Available",
      },
      {
        id: "2",
        name: "Port Scanner",
        description: "Scan open ports on a target IP.",
        category: "recon",
        status: "Available",
      },
      {
        id: "3",
        name: "WAF Detector",
        description: "Detect if a website is behind a WAF.",
        category: "recon",
        status: "Available",
      },
      {
        id: "4",
        name: "Whois Lookup",
        description: "Perform a WHOIS lookup for a domain.",
        category: "recon",
        status: "Under Development",
      },
      {
        id: "5",
        name: "URL Fuzzer",
        description: "Fuzz URLs to discover hidden paths.",
        category: "recon",
        status: "Under Development",
      },
      {
        id: "6",
        name: "Nuclei",
        description: "Fast and customizable vulnerability scanner.",
        category: "vulnerability",
        status: "Under Development",
      },
      {
        id: "7",
        name: "Nikto",
        description: "Web server vulnerability scanner.",
        category: "vulnerability",
        status: "Under Development",
      },
      {
        id: "8",
        name: "XSS Exploiter",
        description: "Exploit XSS vulnerabilities.",
        category: "exploit",
        status: "Under Development",
      },
      {
        id: "9",
        name: "SQLi Exploiter",
        description: "Exploit SQL injection vulnerabilities.",
        category: "exploit",
        status: "Under Development",
      },
      {
        id: "10",
        name: "CVE Map",
        description: "Navigate the CVE jungle with ease.",
        category: "utils",
        status: "Under Development",
      },
    ]
    
    export const getCategoryLabel = (category: string): string => {
      const categoryMap: Record<string, string> = {
        recon: "Reconnaissance",
        vulnerability: "Vulnerability Assessment",
        exploit: "Exploitation",
        utils: "Utilities",
      }
    
      return categoryMap[category] || category.charAt(0).toUpperCase() + category.slice(1)
    }
    
    export const getToolIcon = (toolName: string) => {
      // This function would return an appropriate icon based on the tool name
      // For now, we'll return null and handle icons in the component
      return null
    }
ðŸ“„ lib/utils.ts:
    import { clsx, type ClassValue } from "clsx"
    import { twMerge } from "tailwind-merge"
    
    export function cn(...inputs: ClassValue[]) {
      return twMerge(clsx(inputs))
    }
